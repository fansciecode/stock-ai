{
  "security_issues": [
    {
      "issue": "Encryption key file permissions too permissive",
      "current": "644",
      "recommended": "600",
      "priority": "HIGH"
    },
    {
      "issue": "Missing security measures",
      "missing": [
        "Password hashing (bcrypt)",
        "Password hashing (hashlib)",
        "CSRF protection",
        "JWT tokens",
        "Rate limiting"
      ],
      "priority": "HIGH"
    },
    {
      "issue": "Database file permissions too permissive",
      "file": "src/web_interface/users.db",
      "current": "644",
      "priority": "MEDIUM"
    }
  ],
  "performance_issues": [
    {
      "issue": "AI Model Accuracy Below 80%",
      "current": "66.8%",
      "target": "80%+",
      "priority": "HIGH"
    },
    {
      "issue": "Potential hardcoded data found",
      "files": [
        {
          "file": "src/web_interface/production_dashboard.py",
          "issues": [
            "Demo instrument lists",
            "Random price generation",
            "Test mode indicators",
            "Simulated data",
            "Demo data"
          ]
        },
        {
          "file": "src/web_interface/fixed_continuous_trading_engine.py",
          "issues": [
            "DOGE orders",
            "Random price generation",
            "Simulated data"
          ]
        },
        {
          "file": "src/strategies/real_trading_strategies.py",
          "issues": [
            "Random price generation",
            "Simulated data"
          ]
        },
        {
          "file": "src/data/comprehensive_market_data.py",
          "issues": [
            "DOGE orders"
          ]
        }
      ],
      "priority": "MEDIUM"
    },
    {
      "issue": "DOGE hardcoded in trading engine",
      "file": "src/web_interface/fixed_continuous_trading_engine.py",
      "lines": [
        "Line 1: #!/usr/bin/env python3\n\"\"\"\n\ud83d\udd04 FIXED CONTINUOUS TRADING ENGINE\nAutonomous AI trading with proper asyncio handling and real signals\n\"\"\"\n\nimport sqlite3\nimport json\nimport time\nimport logging\nimport threading\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Any\nimport numpy as np\nimport os\nimport sys\n\n# Add project path\nsys.path.append(os.path.join(os.path.dirname(__file__), 'src'))\n\nclass FixedContinuousTradingEngine:\n    \"\"\"\n    Fixed autonomous trading engine that:\n    1. Places initial orders based on AI signals\n    2. Continuously monitors positions using threading (not asyncio)\n    3. Automatically executes stop-loss/take-profit\n    4. Manages risk and portfolio\n    \"\"\"\n    \n    def __init__(self):\n        self.setup_logging()\n        self.setup_database()\n        \n        # Trading state\n        self.active_sessions = {}  # user_email -> session_data\n        self.monitoring_threads = {}  # user_email -> thread\n        self.is_running = True\n        \n        # Configuration\n        self.monitoring_interval = 10  # seconds (faster updates)\n        self.max_daily_sessions = 5\n        \n        # Import dependencies\n        try:\n            from services.risk_manager import risk_manager\n            self.risk_manager = risk_manager\n        except ImportError:\n            self.logger.warning(\"Risk manager not available\")\n            self.risk_manager = None\n            \n        # Initialize AI model\n        self.ai_model = None\n        self._load_ai_model()\n        \n        # Load any existing active sessions from database\n        self._restore_active_sessions()\n        \n        self.logger.info(\"\ud83e\udd16 Fixed Continuous Trading Engine initialized\")\n        \n    def setup_logging(self):\n        \"\"\"Setup logging\"\"\"\n        os.makedirs(\"logs\", exist_ok=True)\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(levelname)s - %(message)s',\n            handlers=[\n                logging.FileHandler('logs/fixed_continuous_trading.log'),\n                logging.StreamHandler()\n            ]\n        )\n        self.logger = logging.getLogger('FixedContinuousTrading')\n        \n    def setup_database(self):\n        \"\"\"Setup database for persistent trading state\"\"\"\n        os.makedirs(\"data\", exist_ok=True)\n        self.db_path = \"data/fixed_continuous_trading.db\"\n        self.user_db = \"data/users.db\"  # Add missing user_db attribute\n        \n        with sqlite3.connect(self.db_path) as conn:\n            # Active positions table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS active_positions (\n                    position_id TEXT PRIMARY KEY,\n                    user_email TEXT NOT NULL,\n                    symbol TEXT NOT NULL,\n                    side TEXT NOT NULL,\n                    quantity REAL NOT NULL,\n                    entry_price REAL NOT NULL,\n                    current_price REAL NOT NULL,\n                    stop_loss REAL NOT NULL,\n                    take_profit REAL NOT NULL,\n                    entry_time TEXT NOT NULL,\n                    last_update TEXT NOT NULL,\n                    status TEXT DEFAULT 'active',\n                    pnl REAL DEFAULT 0,\n                    pnl_pct REAL DEFAULT 0\n                )\n            \"\"\")\n            \n            # Trading sessions table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS trading_sessions (\n                    session_id TEXT PRIMARY KEY,\n                    user_email TEXT NOT NULL,\n                    start_time TEXT NOT NULL,\n                    end_time TEXT,\n                    status TEXT DEFAULT 'active',\n                    initial_portfolio REAL DEFAULT 10000,\n                    current_portfolio REAL DEFAULT 10000,\n                    total_pnl REAL DEFAULT 0,\n                    trades_count INTEGER DEFAULT 0,\n                    risk_settings TEXT\n                )\n            \"\"\")\n            \n            # Execution log table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS execution_log (\n                    execution_id TEXT PRIMARY KEY,\n                    user_email TEXT NOT NULL,\n                    position_id TEXT,\n                    action TEXT NOT NULL,\n                    symbol TEXT NOT NULL,\n                    price REAL NOT NULL,\n                    quantity REAL NOT NULL,\n                    reason TEXT,\n                    timestamp TEXT NOT NULL,\n                    pnl REAL DEFAULT 0\n                )\n            \"\"\")\n            \n    def _restore_active_sessions(self):\n        \"\"\"Restore active trading sessions from database on startup\"\"\"\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT session_id, user_email, start_time, current_portfolio, \n                           total_pnl, trades_count, risk_settings\n                    FROM trading_sessions \n                    WHERE status = 'active'\n                \"\"\")\n                \n                restored_count = 0\n                for row in cursor.fetchall():\n                    session_id, user_email, start_time, portfolio_value, total_pnl, trades_count, risk_settings = row\n                    \n                    # Restore session data\n                    session_data = {\n                        'session_id': session_id,\n                        'user_email': user_email,\n                        'start_time': start_time,\n                        'status': 'active',\n                        'portfolio_value': portfolio_value,\n                        'risk_settings': json.loads(risk_settings) if risk_settings else {},\n                        'positions': {},\n                        'total_pnl': total_pnl,\n                        'trades_count': trades_count\n                    }\n                    \n                    # Restore active positions\n                    pos_cursor = conn.execute(\"\"\"\n                        SELECT position_id, symbol, side, quantity, entry_price, \n                               current_price, stop_loss, take_profit, entry_time, pnl, pnl_pct\n                        FROM active_positions \n                        WHERE user_email = ? AND status = 'active'\n                    \"\"\", (user_email,))\n                    \n                    for pos_row in pos_cursor.fetchall():\n                        pos_id, symbol, side, quantity, entry_price, current_price, stop_loss, take_profit, entry_time, pnl, pnl_pct = pos_row\n                        \n                        session_data['positions'][pos_id] = {\n                            'position_id': pos_id,\n                            'symbol': symbol,\n                            'side': side,\n                            'quantity': quantity,\n                            'entry_price': entry_price,\n                            'current_price': current_price,\n                            'stop_loss': stop_loss,\n                            'take_profit': take_profit,\n                            'entry_time': entry_time,\n                            'status': 'active',\n                            'pnl': pnl,\n                            'pnl_pct': pnl_pct\n                        }\n                    \n                    # Add to active sessions\n                    self.active_sessions[user_email] = session_data\n                    \n                    # Restart monitoring thread\n                    monitoring_thread = threading.Thread(\n                        target=self._continuous_monitoring_loop,\n                        args=(user_email,),\n                        daemon=True\n                    )\n                    monitoring_thread.start()\n                    self.monitoring_threads[user_email] = monitoring_thread\n                    \n                    restored_count += 1\n                    self.logger.info(f\"\ud83d\udd04 Restored trading session for {user_email} with {len(session_data['positions'])} positions\")\n                \n                if restored_count > 0:\n                    self.logger.info(f\"\ud83c\udfaf Restored {restored_count} active trading sessions\")\n                else:\n                    self.logger.info(\"\ud83d\udced No active trading sessions to restore\")\n                    \n        except Exception as e:\n            self.logger.error(f\"Failed to restore active sessions: {e}\")\n            \n    def start_continuous_trading(self, user_email: str, trading_mode: str = 'TESTNET') -> Dict[str, Any]:\n        \"\"\"Start continuous trading for a user\"\"\"\n        try:\n            # Check if user already has active session\n            if user_email in self.active_sessions:\n                existing_session = self.active_sessions[user_email]\n                # If session is stale (older than 1 hour), clean it up\n                session_start = datetime.fromisoformat(existing_session['start_time'])\n                if (datetime.now() - session_start).total_seconds() > 3600:\n                    self.logger.warning(f\"\ud83e\uddf9 Cleaning up stale session for {user_email}\")\n                    self.stop_continuous_trading(user_email, 'STALE_SESSION_CLEANUP')\n                else:\n                    return {\n                        'success': False,\n                        'error': 'Trading session already active for this user',\n                        'session_id': existing_session['session_id']\n                    }\n                \n            # Get user risk settings\n            risk_settings = {}\n            if self.risk_manager:\n                risk_settings = self.risk_manager.get_risk_settings(user_email)\n                \n            # Log the trading mode\n            self.logger.info(f\"\ud83c\udfaf Starting continuous trading for {user_email} in {trading_mode} mode\")\n            \n            # Create new trading session\n            session_id = f\"session_{user_email}_{int(time.time())}\"\n            session_data = {\n                'session_id': session_id,\n                'user_email': user_email,\n                'start_time': datetime.now().isoformat(),\n                'status': 'active',\n                'trading_mode': trading_mode,  # Store the trading mode\n                'portfolio_value': 10000,  # Starting portfolio\n                'risk_settings': risk_settings,\n                'positions': {},\n                'total_pnl': 0,\n                'trades_count': 0\n            }\n            \n            # Store session in database\n            self._save_session_to_db(session_data)\n            \n            # Generate initial AI signals and place orders\n            initial_result = self._place_initial_orders(user_email, session_data)\n            \n            if not initial_result['success']:\n                return initial_result\n                \n            # Start monitoring task using threading instead of asyncio\n            self.active_sessions[user_email] = session_data\n            \n            # Start continuous monitoring in background thread\n            monitoring_thread = threading.Thread(\n                target=self._continuous_monitoring_loop,\n                args=(user_email,),\n                daemon=True\n            )\n            monitoring_thread.start()\n            self.monitoring_threads[user_email] = monitoring_thread\n            \n            self.logger.info(f\"\ud83d\ude80 Started continuous trading for {user_email}\")\n            \n            return {\n                'success': True,\n                'message': 'Continuous trading started successfully',\n                'session_id': session_id,\n                'initial_positions': len(session_data['positions']),\n                'monitoring_interval': self.monitoring_interval,\n                'risk_settings_applied': bool(self.risk_manager)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error starting continuous trading: {e}\")\n            return {'success': False, 'error': str(e)}\n            \n    def _place_initial_orders(self, user_email: str, session_data: Dict) -> Dict[str, Any]:\n        \"\"\"Place initial orders based on REAL AI signals\"\"\"\n        try:\n            # Get trading mode from session data\n            trading_mode = session_data.get('trading_mode', 'TESTNET')\n            self.logger.info(f\"\ud83c\udfaf Placing orders in {trading_mode} mode for {user_email}\")\n            \n            # Initialize multi-exchange system for LIVE trading\n            live_exchange = None\n            selected_exchange = None\n            exchange_info = {}\n            multi_exchange_results = []\n            \n            if trading_mode == 'LIVE':\n                # Use the new multi-exchange order manager\n                try:\n                    from multi_exchange_order_manager import multi_exchange_manager\n                    from live_binance_trader import LiveBinanceTrader\n                    \n                    # Get user's available exchanges and preferences\n                    exchanges_result = multi_exchange_manager.get_user_available_exchanges(user_email)\n                    prefs_result = multi_exchange_manager.get_user_exchange_preferences(user_email)\n                    \n                    if exchanges_result['success'] and prefs_result['success']:\n                        available_exchanges = list(exchanges_result['exchanges'].keys())\n                        preferences = prefs_result['preferences']\n                        \n                        self.logger.info(f\"\ud83c\udfe6 Available LIVE exchanges: {available_exchanges}\")\n                        self.logger.info(f\"\ud83c\udfaf User preferred exchanges: {preferences['preferred_exchanges']}\")\n                        self.logger.info(f\"\ud83d\udcca Exchange allocation: {preferences['exchange_allocation']}\")\n                        \n                        # For now, connect to primary exchange (Binance) for position creation\n                        # Later we'll create positions across multiple exchanges\n                        binance_keys = None\n                        if 'binance' in available_exchanges:\n                            live_trader = LiveBinanceTrader()\n                            binance_keys = live_trader.get_user_binance_keys(user_email)\n                    \n                        if binance_keys and not binance_keys.get('is_testnet'):\n                            # Create live Binance connection\n                            connection_result = live_trader.create_binance_connection(binance_keys)\n                            if connection_result:\n                                self.logger.info(\"\ud83d\udd34 Connected to LIVE Binance - real money will be used!\")\n                                \n                                # Create CCXT Binance exchange for live trading\n                                import ccxt\n                                import base64\n                                \n                                # Decrypt the API keys (simplified - in production use proper decryption)\n                                api_key = base64.b64decode(binance_keys['api_key']).decode()\n                                secret_key = base64.b64decode(binance_keys['secret_key']).decode()\n                                \n                                live_exchange = ccxt.binance({\n                                    'apiKey': api_key,\n                                    'secret': secret_key,\n                                    'sandbox': False,  # LIVE mode\n                                    'enableRateLimit': True,\n                                })\n                                \n                                # Test the connection by getting balance\n                                balance = live_exchange.fetch_balance()\n                                usdt_balance = balance.get('USDT', {}).get('free', 0)\n                                self.logger.info(f\"\ud83d\udcb0 Live USDT Balance: ${usdt_balance:.2f}\")\n                                \n                                if usdt_balance < 1:\n                                    self.logger.warning(f\"\u26a0\ufe0f Low USDT balance (${usdt_balance:.2f}) - orders may fail\")\n                                \n                                # Save session log indicating live connection\n                                self._save_trading_session_log(user_email, trading_mode, 'LIVE_BINANCE_CONNECTED')\n                                selected_exchange = 'binance'\n                                exchange_info = {'type': 'crypto', 'balance': usdt_balance}\n                            else:\n                                self.logger.warning(\"\u26a0\ufe0f Failed to create Binance connection\")\n                                selected_exchange = None\n                        else:\n                            self.logger.warning(\"\u26a0\ufe0f No live Binance API keys found\")\n                    \n                    # Try Zerodha if Binance failed or not available\n                    if not live_exchange and 'zerodha' in available_exchanges:\n                        self.logger.info(\"\ud83c\uddee\ud83c\uddf3 Attempting Zerodha connection for Indian stock trading...\")\n                        try:\n                            # Test Zerodha connection\n                            zerodha_test = self._test_zerodha_connection(user_email)\n                            if zerodha_test.get('success'):\n                                self.logger.info(f\"\u2705 Zerodha connection successful: {zerodha_test['message']}\")\n                                selected_exchange = 'zerodha'\n                                exchange_info = {'type': 'indian_stocks', 'supports': ['NSE', 'BSE']}\n                            else:\n                                self.logger.warning(f\"\u26a0\ufe0f Zerodha connection failed: {zerodha_test.get('error')}\")\n                        except Exception as ze:\n                            self.logger.warning(f\"\u26a0\ufe0f Zerodha test error: {ze}\")\n                    \n                    # Log final exchange selection\n                    if live_exchange:\n                        self.logger.info(f\"\u2705 Using {selected_exchange or 'binance'} for live trading\")\n                        exchange_info['connected'] = True\n                    elif selected_exchange:\n                        self.logger.info(f\"\u2705 Using {selected_exchange} for live trading\")\n                        exchange_info['connected'] = True\n                    else:\n                        self.logger.warning(\"\u26a0\ufe0f No live exchanges available - but forcing LIVE mode\")\n                        trading_mode = 'LIVE'  # Force LIVE mode even without exchange connections\n                        \n                except Exception as e:\n                    self.logger.warning(f\"\u26a0\ufe0f Could not connect to live exchanges: {e}\")\n                    self.logger.info(\"\ud83d\udd34 Forcing LIVE mode despite connection issues\")\n                    trading_mode = 'LIVE'  # Force LIVE mode\n            \n            # Generate REAL dynamic signals and use multi-exchange system\n            positions_created = 0\n            \n            # Get real instruments from database - NOW USING UP TO 500 INSTRUMENTS\n            instruments = self._get_random_instruments(500)\n            \n            # Check if we have live exchange connections\n            has_live_exchanges = live_exchange is not None or selected_exchange is not None\n            \n            # Force LIVE mode if trading_mode is LIVE\n            if trading_mode == 'LIVE':\n                has_live_exchanges = True  # Override for LIVE mode\n                self.logger.info(\"\ud83d\udd34 FORCING LIVE MODE - Will execute real orders\")\n            \n            self.logger.info(f\"\ud83c\udfaf Order execution mode: {'\ud83d\udd34 LIVE EXCHANGES' if has_live_exchanges else '\ud83c\udfad SIMULATION'}\")\n            \n            for instrument in instruments:\n                # Generate realistic signal based on current time and market conditions\n                signal_strength = np.random.uniform(70, 95)  # Only strong signals\n                confidence = np.random.uniform(80, 99)\n                \n                # Use real price movement patterns\n                base_price = instrument.get('market_cap', 1000) / 1000000  # Realistic pricing\n                current_price = base_price * (1 + np.random.uniform(-0.02, 0.02))\n                \n                # Apply user's risk settings\n                risk_settings = session_data['risk_settings']\n                stop_loss_pct = risk_settings.get('stop_loss_pct', 0.02)\n                take_profit_pct = risk_settings.get('take_profit_pct', 0.04)\n                max_position_pct = risk_settings.get('max_position_size', 0.20)\n                \n                # Calculate position details\n                max_position_value = session_data['portfolio_value'] * max_position_pct\n                quantity = max_position_value / current_price\n                \n                # Use AI to generate the signal\n                ai_signal = self._generate_ai_signal(instrument)\n                signal_type = ai_signal['signal']\n                signal_strength = ai_signal['strength']\n                confidence = signal_strength\n                \n                if signal_type == 'BUY':\n                    stop_loss = current_price * (1 - stop_loss_pct)\n                    take_profit = current_price * (1 + take_profit_pct)\n                else:\n                    stop_loss = current_price * (1 + stop_loss_pct)\n                    take_profit = current_price * (1 - take_profit_pct)\n                \n                # Check if we already have a position for this symbol (prevent duplicates)\n                existing_positions = [pos for pos in session_data['positions'].values() \n                                    if pos.get('symbol') == instrument['symbol'] and pos.get('status') == 'active']\n                if existing_positions:\n                    self.logger.info(f\"\u23ed\ufe0f Skipping {instrument['symbol']} - already have active position\")\n                    continue\n                \n                # Additional check: prevent creating more than 5 positions total\n                active_positions = [pos for pos in session_data.get('positions', {}).values() \n                                  if pos.get('status') == 'active']\n                if len(active_positions) >= 5:\n                    self.logger.info(f\"\u23ed\ufe0f Maximum positions reached ({len(active_positions)}), stopping creation\")\n                    break\n                \n                position_id = f\"pos_{instrument['symbol'].replace(':', '_')}_{int(time.time())}_{positions_created}\"\n                \n                position = {\n                    'position_id': position_id,\n                    'symbol': instrument['symbol'],\n                    'side': signal_type,\n                    'quantity': quantity,\n                    'entry_price': current_price,\n                    'current_price': current_price,\n                    'stop_loss': stop_loss,\n                    'take_profit': take_profit,\n                    'entry_time': datetime.now().isoformat(),\n                    'status': 'active',\n                    'trading_mode': trading_mode,  # Track trading mode\n                    'pnl': 0,\n                    'pnl_pct': 0,\n                    'signal_strength': signal_strength,\n                    'confidence': confidence\n                }\n                \n                # Save position to database\n                self._save_position_to_db(user_email, position)\n                \n                # Try to place REAL order using multi-exchange system if in LIVE mode\n                real_order_result = None\n                if has_live_exchanges and trading_mode == 'LIVE':\n                    try:\n                        # Try different asset types based on position count\n                        if positions_created % 2 == 0:\n                            # Crypto order on Binance\n                            order_data = {\n                                'symbol': 'DOGE/USDT',  # Use DOGE (lower minimums)\n                                'side': signal_type,\n                                'amount': 0.1  # $0.10 order to test minimum\n                            }\n                            asset_type = 'crypto'\n                        else:\n                            # Indian stock order on Zerodha\n                            order_data = {\n                                'symbol': 'RELIANCE.NSE',  # Popular Indian stock\n                                'side': signal_type,\n                                'amount': 100  # \u20b9100 (~$1.20) for Indian stock\n                            }\n                            asset_type = 'indian_stocks'\n                        \n                        self.logger.info(f\"\ud83c\udfaf Attempting {asset_type} order: {order_data['symbol']} {order_data['side']} ${order_data['amount']:.2f}\")\n                        \n                        # Route order through multi-exchange system\n                        from multi_exchange_order_manager import multi_exchange_manager\n                        routing_result = multi_exchange_manager.route_order_to_exchanges(\n                            order_data['symbol'], \n                            order_data['side'], \n                            order_data['amount']\n                        )\n                        \n                        if routing_result.get('success') and routing_result.get('execution_results'):\n                            # Use first successful execution result\n                            for execution in routing_result['execution_results']:\n                                if execution['result'].get('success'):\n                                    real_order_result = execution['result']\n                                    exchange_name = execution['exchange'].upper()\n                                    currency = real_order_result.get('currency', 'USD')\n                                    amount_display = f\"${real_order_result['amount']:.2f}\" if currency == 'USD' else f\"\u20b9{real_order_result['amount']:.2f}\"\n                                    \n                                    self.logger.info(f\"\ud83d\udd34 LIVE ORDER via {exchange_name}: {real_order_result['symbol']} {real_order_result['side']} {amount_display}\")\n                                    self.logger.info(f\"   \ud83d\udcb0 Price: {currency}{'$' if currency == 'USD' else '\u20b9'}{real_order_result['price']:.2f}\")\n                                    self.logger.info(f\"   \ud83d\udd22 Quantity: {real_order_result['quantity']}\")\n                                    self.logger.info(f\"   \ud83c\udd94 Order ID: {real_order_result['order_id']}\")\n                                    break\n                        \n                        if not real_order_result:\n                            self.logger.warning(\"\u26a0\ufe0f Multi-exchange routing failed - will create simulated position\")\n                            \n                    except Exception as order_error:\n                        self.logger.error(f\"\u274c Multi-exchange order failed: {order_error}\")\n                        real_order_result = None\n                        \n                        # Calculate order amount based on ACTUAL available balance\n                        # Get real balance from exchange\n                        try:\n                            if live_exchange:\n                                balance = live_exchange.fetch_balance()\n                                available_balance = balance.get('USDT', {}).get('free', 0)\n                            else:\n                                # Use multi-exchange manager for balance\n                                from multi_exchange_order_manager import multi_exchange_manager\n                                balance = multi_exchange_manager.fetch_balance('binance')\n                                available_balance = balance.get('USDT', 2.9)  # Default to known balance\n                        except Exception as balance_error:\n                            self.logger.warning(f\"\u26a0\ufe0f Could not get balance: {balance_error}\")\n                            available_balance = 2.9  # Use known balance\n                        \n                        # Use smaller percentage for limited balance\n                        usdt_amount = min(available_balance * 0.8, 0.5)  # Use 80% of balance, max $0.50 per order\n                        \n                        # Ensure minimum for DOGE/SHIB (some pairs accept $0.10 minimum)\n                        if usdt_amount < 0.10:\n                            self.logger.warning(f\"\u26a0\ufe0f Balance too low: ${usdt_amount:.3f}, using minimum $0.10\")\n                            usdt_amount = 0.10  # Use minimum amount\n                        \n                        quantity = usdt_amount / market_price\n                        \n                        if signal_type == 'BUY':\n                            # Place live BUY order\n                            real_order = live_exchange.create_market_buy_order(trading_symbol, quantity)\n                            real_order_result = {\n                                'order_id': real_order['id'],\n                                'symbol': trading_symbol,\n                                'side': 'BUY',\n                                'amount': quantity,\n                                'price': market_price,\n                                'exchange': 'binance_live',\n                                'cost': real_order.get('cost', usdt_amount)\n                            }\n                            self.logger.info(f\"\ud83d\udd34 LIVE BUY ORDER: {quantity:.6f} {trading_symbol} at ${market_price:.2f} = ${usdt_amount:.2f}\")\n                            \n                        elif signal_type == 'SELL':\n                            # For SELL, we need existing balance - skip for now\n                            self.logger.info(f\"\u23f8\ufe0f LIVE SELL skipped - need existing {trading_symbol.split('/')[0]} balance\")\n                            \n                    except Exception as order_error:\n                        # DETAILED ERROR LOGGING for failed orders\n                        error_msg = str(order_error)\n                        self.logger.error(f\"\u274c DETAILED ORDER FAILURE ANALYSIS:\")\n                        self.logger.error(f\"   \ud83d\udcb1 Exchange: {selected_exchange or 'binance'}\")\n                        self.logger.error(f\"   \ud83d\udcca Symbol: {trading_symbol}\")\n                        self.logger.error(f\"   \ud83d\udcb0 Order Amount: ${usdt_amount:.2f}\")\n                        self.logger.error(f\"   \ud83d\udd22 Quantity: {quantity:.8f}\")\n                        self.logger.error(f\"   \ud83d\udcb5 Market Price: ${market_price:.6f}\")\n                        self.logger.error(f\"   \ud83c\udfe6 Available Balance: ${available_balance:.2f}\")\n                        self.logger.error(f\"   \u274c Error Code: {error_msg}\")\n                        \n                        # Try to parse Binance error codes\n                        if 'code' in error_msg:\n                            if '-1013' in error_msg:\n                                self.logger.error(f\"   \ud83d\udd0d NOTIONAL Error: Order value too small for {trading_symbol}\")\n                                self.logger.error(f\"   \ud83d\udca1 Solution: Need larger order (min ~$5-10 for most pairs)\")\n                            elif '-2010' in error_msg:\n                                self.logger.error(f\"   \ud83d\udd0d INSUFFICIENT_BALANCE: Not enough USDT\")\n                            elif '-1021' in error_msg:\n                                self.logger.error(f\"   \ud83d\udd0d TIMESTAMP Error: Server time sync issue\")\n                            elif '-2015' in error_msg:\n                                self.logger.error(f\"   \ud83d\udd0d API_KEY Error: Invalid permissions\")\n                                \n                        real_order_result = None\n                        \n                # Update position with live order info or mark as simulated\n                if real_order_result:\n                    # LIVE order was placed successfully\n                    position['live_order'] = real_order_result\n                    position['exchange'] = f\"{real_order_result['exchange']}_live\"\n                    position['symbol'] = real_order_result['symbol']  # Use actual traded symbol\n                    position['entry_price'] = real_order_result['price']\n                    position['current_price'] = real_order_result['price']\n                    position['order_id'] = real_order_result.get('order_id', 'N/A')\n                    exchange_display = f\"\ud83d\udd34 LIVE ({real_order_result['exchange'].upper()})\"\n                    actual_symbol = real_order_result['symbol']\n                    actual_price = real_order_result['price']\n                else:\n                    # No live order - create simulated position\n                    position['exchange'] = 'simulated'\n                    exchange_display = \"\ud83c\udfad SIMULATED\"\n                    actual_symbol = instrument['symbol']\n                    actual_price = current_price\n                \n                # Add to session\n                session_data['positions'][position_id] = position\n                positions_created += 1\n                \n                # Get instrument details for better logging\n                instrument_name = instrument.get('name', 'Unknown Company')\n                instrument_exchange = instrument.get('exchange', 'Unknown Exchange')\n                instrument_class = instrument.get('asset_class', 'Stock')\n                \n                # Calculate stop-loss and take-profit levels\n                stop_loss_price = actual_price * (0.98 if signal_type == 'BUY' else 1.02)\n                take_profit_price = actual_price * (1.04 if signal_type == 'BUY' else 0.96)\n                \n                # Enhanced logging with detailed trade information\n                self.logger.info(f\"\ud83d\udcca Created {exchange_display} position: {actual_symbol} ({instrument_name})\")\n                self.logger.info(f\"   \ud83d\udcc8 Action: {signal_type} {instrument_class} at ${actual_price:.2f}\")\n                self.logger.info(f\"   \ud83c\udfaf Signal Strength: {signal_strength:.1f}% | Exchange: {instrument_exchange}\")\n                self.logger.info(f\"   \ud83d\udee1\ufe0f Stop Loss: ${stop_loss_price:.2f} | \ud83c\udfaf Take Profit: ${take_profit_price:.2f}\")\n                \n                # Store stop-loss and take-profit in position data\n                position['stop_loss'] = stop_loss_price\n                position['take_profit'] = take_profit_price\n                position['instrument_name'] = instrument_name\n                \n                # Log order details if real order was placed\n                if real_order_result:\n                    self.logger.info(f\"   \ud83d\udcb0 Order Amount: ${real_order_result['amount']:.2f}\")\n                    self.logger.info(f\"   \ud83d\udd22 Quantity: {real_order_result.get('quantity', 'N/A')}\")\n                    self.logger.info(f\"   \ud83c\udd94 Order ID: {real_order_result.get('order_id', 'N/A')}\")\n                    self.logger.info(f\"   \u2705 LIVE ORDER EXECUTED on {real_order_result['exchange'].upper()}\")\n                else:\n                    # Calculate simulated position details\n                    portfolio_value = session_data.get('portfolio_value', 10000)\n                    position_size = portfolio_value * 0.1  # 10% of portfolio per position\n                    quantity = position_size / actual_price\n                    self.logger.info(f\"   \ud83d\udcb0 Simulated Amount: ${position_size:.2f}\")\n                    self.logger.info(f\"   \ud83d\udd22 Simulated Quantity: {quantity:.4f}\")\n                    self.logger.info(f\"   \ud83c\udfad SIMULATION MODE - No real money at risk\")\n                \n                if positions_created >= 3:  # Limit to 3 initial positions\n                    break\n                \n            session_data['trades_count'] = positions_created\n            \n            return {\n                'success': True,\n                'positions_created': positions_created,\n                'signals_analyzed': len(instruments)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error placing initial orders: {e}\")\n            return {'success': False, 'error': str(e)}\n            \n    def _get_random_instruments(self, limit: int = 1000) -> List[Dict]:\n        \"\"\"Get random instruments from database - NOW USING ALL INSTRUMENTS with clean symbols\"\"\"\n        try:\n            with sqlite3.connect(\"data/instruments.db\") as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT symbol, name, exchange, asset_class, market_cap \n                    FROM instruments \n                    WHERE market_cap > 0\n                    ORDER BY RANDOM() \n                    LIMIT ?\n                \"\"\", (limit,))\n                \n                instruments = []\n                for row in cursor.fetchall():\n                    original_symbol = row[0]\n                    clean_symbol = original_symbol\n                    \n                    # Clean up numeric placeholder symbols (NYSE2481.NYSE -> NYSE:2481)\n                    if '.' in original_symbol:\n                        parts = original_symbol.split('.')\n                        if len(parts) == 2:\n                            symbol_id, exchange = parts\n                            # Check if it's a numeric placeholder\n                            if any(x in exchange for x in ['NYSE', 'NASDAQ', 'NSE', 'BSE']) and symbol_id.replace(exchange, '').isdigit():\n                                # Convert NYSE2481.NYSE to NYSE:2481\n                                clean_id = symbol_id.replace(exchange, '')\n                                clean_symbol = f\"{exchange}:{clean_id}\"\n                            else:\n                                # Keep normal symbols like RELIANCE.NSE as RELIANCE:NSE\n                                clean_symbol = f\"{symbol_id}:{exchange}\"\n                    \n                    instruments.append({\n                        'symbol': clean_symbol,\n                        'original_symbol': original_symbol,  # Keep original for database queries\n                        'name': row[1],\n                        'exchange': row[2],\n                        'asset_class': row[3],\n                        'market_cap': row[4] or np.random.uniform(1000000000, 100000000000)\n                    })\n                return instruments\n        except Exception as e:\n            self.logger.error(f\"Error getting instruments: {e}\")\n            # Fallback to hardcoded instruments\n            return [\n                {'symbol': 'RELIANCE.NSE', 'name': 'Reliance Industries', 'exchange': 'NSE', 'asset_class': 'equity', 'market_cap': 15000000000000},\n                {'symbol': 'TCS.NSE', 'name': 'Tata Consultancy Services', 'exchange': 'NSE', 'asset_class': 'equity', 'market_cap': 12000000000000},\n                {'symbol': 'INFY.NSE', 'name': 'Infosys Limited', 'exchange': 'NSE', 'asset_class': 'equity', 'market_cap': 8000000000000},\n                {'symbol': 'HDFCBANK.NSE', 'name': 'HDFC Bank', 'exchange': 'NSE', 'asset_class': 'equity', 'market_cap': 10000000000000},\n                {'symbol': 'BHARTIARTL.NSE', 'name': 'Bharti Airtel', 'exchange': 'NSE', 'asset_class': 'equity', 'market_cap': 5000000000000}\n            ]\n            \n    def _continuous_monitoring_loop(self, user_email: str):\n        \"\"\"Continuous monitoring loop for a user's positions (using threading)\"\"\"\n        self.logger.info(f\"\ud83d\udd04 Starting monitoring loop for {user_email}\")\n        \n        try:\n            while user_email in self.active_sessions and self.is_running:\n                session_data = self.active_sessions[user_email]\n                \n                if session_data['status'] != 'active':\n                    break\n                    \n                # Get current market prices (realistic simulation)\n                current_prices = self._get_realistic_market_prices(session_data['positions'])\n                \n                # Check each position for exit conditions\n                self._check_exit_conditions(user_email, session_data, current_prices)\n                \n                # Update session in database\n                self._update_session_in_db(session_data)\n                \n                # Check daily loss limits\n                self._check_daily_limits(user_email, session_data)\n                \n                # Wait before next check\n                time.sleep(self.monitoring_interval)\n                \n        except Exception as e:\n            self.logger.error(f\"Error in monitoring loop for {user_email}: {e}\")\n        finally:\n            # Clean up\n            if user_email in self.monitoring_threads:\n                del self.monitoring_threads[user_email]\n                \n    def _get_realistic_market_prices(self, positions: Dict) -> Dict[str, float]:\n        \"\"\"Get realistic market prices with proper volatility\"\"\"\n        current_prices = {}\n        \n        for position_id, position in positions.items():\n            symbol = position['symbol']\n            entry_price = position['entry_price']\n            entry_time = datetime.fromisoformat(position['entry_time'])\n            \n            # Calculate time-based price movement\n            time_elapsed = (datetime.now() - entry_time).total_seconds() / 60  # minutes\n            \n            # Realistic price movement based on time and volatility\n            base_volatility = 0.002  # 0.2% base volatility per minute\n            trend_factor = np.sin(time_elapsed / 30) * 0.01  # 30-minute cycles\n            \n            # Add some randomness but keep it realistic\n            np.random.seed(int(time.time() / 60) + hash(symbol) % 1000)  # Change every minute\n            random_movement = np.random.normal(0, base_volatility)\n            \n            # Combine trend and random movement\n            total_movement = trend_factor + random_movement\n            current_price = entry_price * (1 + total_movement)\n            \n            # Ensure price doesn't go too extreme\n            max_change = 0.10  # Max 10% change from entry\n            if abs(current_price - entry_price) / entry_price > max_change:\n                direction = 1 if current_price > entry_price else -1\n                current_price = entry_price * (1 + direction * max_change)\n            \n            current_prices[symbol] = current_price\n            \n        return current_prices\n    \n    def _get_live_market_price(self, symbol: str, exchange: str) -> Optional[float]:\n        \"\"\"Get real market price from live exchange\"\"\"\n        try:\n            if 'binance' in exchange:\n                from live_binance_trader import LiveBinanceTrader\n                \n                trader = LiveBinanceTrader()\n                # Use a cached connection for efficiency\n                if not hasattr(self, '_live_exchange_cache'):\n                    self._live_exchange_cache = {}\n                \n                if 'binance' not in self._live_exchange_cache:\n                    api_keys = trader.get_user_binance_keys('kirannaik@unitednewdigitalmedia.com')  # Hardcoded for now\n                    if api_keys:\n                        connection = trader.create_binance_connection(api_keys)\n                        if connection:\n                            self._live_exchange_cache['binance'] = connection\n                \n                if 'binance' in self._live_exchange_cache:\n                    ticker = self._live_exchange_cache['binance'].fetch_ticker(symbol)\n                    return ticker.get('last') or ticker.get('close')\n                    \n        except Exception as e:\n            self.logger.debug(f\"Error getting live price for {symbol}: {e}\")\n            \n        return None\n        \n    def _check_exit_conditions(self, user_email: str, session_data: Dict, \n                             current_prices: Dict[str, float]):\n        \"\"\"Check if any positions should be closed\"\"\"\n        positions_to_close = []\n        \n        for position_id, position in session_data['positions'].items():\n            if position['status'] != 'active':\n                continue\n                \n            symbol = position['symbol']\n            if symbol not in current_prices:\n                continue\n                \n            current_price = current_prices[symbol]\n            entry_price = position['entry_price']\n            stop_loss = position['stop_loss']\n            take_profit = position['take_profit']\n            side = position['side']\n            \n            # Update current price and P&L\n            position['current_price'] = current_price\n            \n            if side == 'BUY':\n                pnl_pct = (current_price - entry_price) / entry_price\n                pnl = position['quantity'] * (current_price - entry_price)\n                \n                # Check exit conditions\n                if current_price <= stop_loss:\n                    positions_to_close.append((position_id, 'STOP_LOSS', current_price))\n                elif current_price >= take_profit:\n                    positions_to_close.append((position_id, 'TAKE_PROFIT', current_price))\n                    \n            else:  # SELL\n                pnl_pct = (entry_price - current_price) / entry_price\n                pnl = position['quantity'] * (entry_price - current_price)\n                \n                # Check exit conditions\n                if current_price >= stop_loss:\n                    positions_to_close.append((position_id, 'STOP_LOSS', current_price))\n                elif current_price <= take_profit:\n                    positions_to_close.append((position_id, 'TAKE_PROFIT', current_price))\n                    \n            # Update position P&L\n            position['pnl'] = pnl\n            position['pnl_pct'] = pnl_pct\n            \n        # Execute closes\n        for position_id, reason, exit_price in positions_to_close:\n            self._close_position(user_email, session_data, position_id, reason, exit_price)\n            \n    def _close_position(self, user_email: str, session_data: Dict, \n                      position_id: str, reason: str, exit_price: float):\n        \"\"\"Close a position and execute REAL sell order if it's a live position\"\"\"\n        try:\n            if position_id not in session_data['positions']:\n                self.logger.warning(f\"Position {position_id} not found for closure\")\n                return\n                \n            position = session_data['positions'][position_id]\n            \n            # Check if position is already closed to prevent duplicates\n            if position.get('status') == 'closed':\n                self.logger.warning(f\"Position {position_id} already closed, skipping duplicate closure\")\n                return\n                \n            exchange = position.get('exchange', 'simulated')\n            \n            # Calculate final P&L\n            entry_price = position['entry_price']\n            quantity = position['quantity']\n            \n            if position['side'] == 'BUY':\n                pnl = quantity * (exit_price - entry_price)\n            else:\n                pnl = quantity * (entry_price - exit_price)\n                \n            pnl_pct = (pnl / (quantity * entry_price)) * 100\n            \n            # Execute REAL sell order if this is a live position\n            real_close_order = None\n            if 'live' in exchange and position.get('live_order'):\n                real_close_order = self._execute_live_close_order(user_email, position, exit_price)\n            \n            # Update position status\n            position['status'] = 'closed'\n            position['exit_price'] = exit_price\n            position['exit_time'] = datetime.now().isoformat()\n            position['exit_reason'] = reason\n            position['final_pnl'] = pnl\n            position['final_pnl_pct'] = pnl_pct\n            position['close_order'] = real_close_order  # Store close order details\n            \n            # Update session totals\n            session_data['total_pnl'] += pnl\n            session_data['portfolio_value'] += pnl\n            \n            # Log execution\n            execution_id = f\"exec_{position_id}_{int(time.time())}\"\n            execution = {\n                'execution_id': execution_id,\n                'user_email': user_email,\n                'position_id': position_id,\n                'action': 'CLOSE',\n                'symbol': position['symbol'],\n                'price': exit_price,\n                'quantity': quantity,\n                'reason': reason,\n                'timestamp': datetime.now().isoformat(),\n                'pnl': pnl\n            }\n            \n            # Save to database\n            self._save_execution_to_db(execution)\n            self._update_position_in_db(user_email, position)\n            \n            # Enhanced closure logging with detailed information\n            profit_emoji = \"\ud83d\udcc8\" if pnl > 0 else \"\ud83d\udcc9\"\n            instrument_name = position.get('instrument_name', 'Unknown Company')\n            entry_price = position.get('entry_price', position.get('current_price', 0))\n            stop_loss = position.get('stop_loss', 0)\n            take_profit = position.get('take_profit', 0)\n            \n            # Determine closure reason details\n            closure_detail = \"\"\n            if reason == \"STOP_LOSS\":\n                closure_detail = f\" \ud83d\udee1\ufe0f STOP LOSS TRIGGERED (Set: ${stop_loss:.2f})\"\n            elif reason == \"TAKE_PROFIT\":\n                closure_detail = f\" \ud83c\udfaf TAKE PROFIT HIT (Target: ${take_profit:.2f})\"\n            elif reason == \"USER_REQUEST\":\n                closure_detail = \" \ud83d\udc64 MANUALLY CLOSED\"\n            elif reason == \"TIME_EXIT\":\n                closure_detail = \" \u23f0 TIME-BASED EXIT\"\n            \n            self.logger.info(f\"{profit_emoji} POSITION CLOSED: {position['symbol']} ({instrument_name})\")\n            self.logger.info(f\"   \ud83d\udcca Entry: ${entry_price:.2f} \u2192 Exit: ${exit_price:.2f}{closure_detail}\")\n            self.logger.info(f\"   \ud83d\udcb0 P&L: ${pnl:+.2f} ({pnl_pct:+.1f}%) | Hold Time: {position.get('hold_time', 'N/A')}\")\n            \n            # Log exchange details\n            if position.get('exchange') == 'simulated':\n                self.logger.info(f\"   \ud83c\udfad SIMULATION - No real money involved\")\n            else:\n                self.logger.info(f\"   \u2705 LIVE TRADE on {position.get('exchange', 'UNKNOWN').upper()}\")\n                           \n            # Check if all positions are closed\n            active_positions = [p for p in session_data['positions'].values() \n                             if p['status'] == 'active']\n            \n            if not active_positions:\n                self.logger.info(f\"\u2705 All positions closed for {user_email}\")\n                self._consider_new_signals(user_email, session_data)\n                \n        except Exception as e:\n            self.logger.error(f\"Error closing position {position_id}: {e}\")\n    \n    def _execute_live_close_order(self, user_email: str, position: Dict, exit_price: float) -> Dict[str, Any]:\n        \"\"\"Execute real close order on live exchange\"\"\"\n        try:\n            live_order = position.get('live_order', {})\n            exchange_name = live_order.get('exchange', 'binance')\n            symbol = live_order.get('symbol', 'BTC/USDT')\n            quantity = live_order.get('quantity', 0)\n            \n            self.logger.info(f\"\ud83d\udd34 Executing LIVE close order: {symbol} on {exchange_name}\")\n            \n            if exchange_name == 'binance':\n                # Execute Binance sell order\n                try:\n                    from live_binance_trader import LiveBinanceTrader\n                    \n                    trader = LiveBinanceTrader()\n                    api_keys = trader.get_user_binance_keys(user_email)\n                    \n                    if api_keys and not api_keys.get('is_testnet'):\n                        connection = trader.create_binance_connection(api_keys)\n                        if connection:\n                            # Place market sell order to close position\n                            close_order = connection.create_market_sell_order(symbol, quantity)\n                            \n                            self.logger.info(f\"\u2705 LIVE SELL ORDER executed: {quantity:.6f} {symbol} at market price\")\n                            self.logger.info(f\"   \ud83c\udd94 Close Order ID: {close_order.get('id', 'N/A')}\")\n                            self.logger.info(f\"   \ud83d\udcb0 Close Order Cost: ${close_order.get('cost', 0):.2f}\")\n                            \n                            return {\n                                'success': True,\n                                'order_id': close_order.get('id'),\n                                'symbol': symbol,\n                                'quantity': quantity,\n                                'side': 'SELL',\n                                'exchange': 'binance',\n                                'type': 'market',\n                                'cost': close_order.get('cost', 0)\n                            }\n                        else:\n                            self.logger.error(\"\u274c Failed to connect to Binance for close order\")\n                    else:\n                        self.logger.error(\"\u274c No live Binance API keys for close order\")\n                        \n                except Exception as binance_error:\n                    self.logger.error(f\"\u274c Binance close order failed: {binance_error}\")\n                    \n            elif exchange_name == 'zerodha':\n                # Placeholder for Zerodha close order\n                self.logger.info(f\"\ud83c\uddee\ud83c\uddf3 Zerodha close order simulation: SELL {quantity:.6f} {symbol}\")\n                return {\n                    'success': True,\n                    'order_id': f\"ZD_CLOSE_{int(time.time())}\",\n                    'symbol': symbol,\n                    'quantity': quantity,\n                    'side': 'SELL',\n                    'exchange': 'zerodha',\n                    'type': 'simulated'\n                }\n            \n            # Return failure if no order was executed\n            return {\n                'success': False,\n                'error': f'Failed to execute close order on {exchange_name}',\n                'exchange': exchange_name\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"\u274c Live close order execution failed: {e}\")\n            return {\n                'success': False,\n                'error': str(e)\n            }\n            \n    def _consider_new_signals(self, user_email: str, session_data: Dict):\n        \"\"\"Consider new signals after all positions are closed\"\"\"\n        try:\n            # Check daily limits first\n            if session_data['trades_count'] >= 3:  # Max 3 rounds per day\n                self.logger.info(f\"\ud83d\uded1 Daily trade limit reached for {user_email}\")\n                return\n                \n            # Check daily loss\n            if self.risk_manager:\n                risk_settings = session_data['risk_settings']\n                max_daily_loss = risk_settings.get('max_daily_loss', 0.05) * session_data['portfolio_value']\n                if session_data['total_pnl'] <= -max_daily_loss:\n                    self.logger.info(f\"\ud83d\udea8 Daily loss limit hit for {user_email}\")\n                    self.stop_continuous_trading(user_email, 'DAILY_LOSS_LIMIT')\n                    return\n                    \n            # Generate new signals\n            self.logger.info(f\"\ud83c\udfaf Looking for new opportunities for {user_email}\")\n            new_orders_result = self._place_initial_orders(user_email, session_data)\n            \n            if new_orders_result['success'] and new_orders_result['positions_created'] > 0:\n                session_data['trades_count'] += 1\n                self.logger.info(f\"\ud83d\udd04 Started new trading round {session_data['trades_count']} \"\n                               f\"for {user_email}\")\n            else:\n                self.logger.info(f\"\u23f8\ufe0f No new opportunities found for {user_email}\")\n                \n        except Exception as e:\n            self.logger.error(f\"Error considering new signals: {e}\")\n            \n    def _check_daily_limits(self, user_email: str, session_data: Dict):\n        \"\"\"Check if daily limits are exceeded\"\"\"\n        try:\n            if not self.risk_manager:\n                return\n                \n            risk_settings = session_data['risk_settings']\n            max_daily_loss_pct = risk_settings.get('max_daily_loss', 0.05)\n            max_daily_loss = max_daily_loss_pct * session_data['portfolio_value']\n            \n            if session_data['total_pnl'] <= -max_daily_loss:\n                self.logger.warning(f\"\ud83d\udea8 Daily loss limit exceeded for {user_email}: \"\n                                  f\"${session_data['total_pnl']:+.2f}\")\n                self.stop_continuous_trading(user_email, 'DAILY_LOSS_LIMIT')\n                \n        except Exception as e:\n            self.logger.error(f\"Error checking daily limits: {e}\")\n            \n    def stop_continuous_trading(self, user_email: str, reason: str = 'USER_REQUEST') -> Dict[str, Any]:\n        \"\"\"Stop continuous trading for a user\"\"\"\n        try:\n            if user_email not in self.active_sessions:\n                return {'success': False, 'error': 'No active session found'}\n                \n            session_data = self.active_sessions[user_email]\n            \n            # Close all active positions\n            active_positions = [p for p in session_data['positions'].values() \n                              if p['status'] == 'active']\n            \n            for position in active_positions:\n                # Get current price for final close\n                current_prices = self._get_realistic_market_prices({position['position_id']: position})\n                current_price = current_prices.get(position['symbol'], position['current_price'])\n                \n                self._close_position(user_email, session_data, \n                                   position['position_id'], reason, current_price)\n                \n            # Update session status\n            session_data['status'] = 'completed'\n            session_data['end_time'] = datetime.now().isoformat()\n            session_data['stop_reason'] = reason\n            \n            # Save final session state\n            self._update_session_in_db(session_data)\n            \n            # Remove from active sessions\n            del self.active_sessions[user_email]\n            \n            self.logger.info(f\"\ud83d\uded1 Stopped continuous trading for {user_email} \"\n                           f\"(Reason: {reason}, Final P&L: ${session_data['total_pnl']:+.2f})\")\n            \n            return {\n                'success': True,\n                'message': 'Continuous trading stopped',\n                'reason': reason,\n                'final_pnl': session_data['total_pnl'],\n                'trades_executed': session_data['trades_count'],\n                'session_duration': self._calculate_session_duration(session_data)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error stopping continuous trading: {e}\")\n            return {'success': False, 'error': str(e)}\n            \n    def get_trading_status(self, user_email: str) -> Dict[str, Any]:\n        \"\"\"Get current trading status for a user\"\"\"\n        try:\n            if user_email not in self.active_sessions:\n                return {'active': False, 'message': 'No active trading session'}\n                \n            session_data = self.active_sessions[user_email]\n            \n            # Calculate current statistics\n            active_positions = [p for p in session_data['positions'].values() \n                              if p['status'] == 'active']\n            closed_positions = [p for p in session_data['positions'].values() \n                              if p['status'] == 'closed']\n            \n            current_pnl = sum(p.get('pnl', 0) for p in active_positions)\n            realized_pnl = sum(p.get('final_pnl', 0) for p in closed_positions)\n            total_pnl = current_pnl + realized_pnl\n            \n            return {\n                'active': True,\n                'session_id': session_data['session_id'],\n                'start_time': session_data['start_time'],\n                'portfolio_value': session_data['portfolio_value'],\n                'active_positions': len(active_positions),\n                'closed_positions': len(closed_positions),\n                'current_pnl': current_pnl,\n                'realized_pnl': realized_pnl,\n                'total_pnl': total_pnl,\n                'trades_count': session_data['trades_count'],\n                'monitoring_active': user_email in self.monitoring_threads,\n                'risk_settings_applied': bool(self.risk_manager)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error getting trading status: {e}\")\n            return {'active': False, 'error': str(e)}\n            \n    # Database helper methods\n    def _save_session_to_db(self, session_data: Dict):\n        \"\"\"Save trading session to database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO trading_sessions \n                (session_id, user_email, start_time, status, initial_portfolio, \n                 current_portfolio, total_pnl, trades_count, risk_settings)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n            \"\"\", (\n                session_data['session_id'],\n                session_data['user_email'],\n                session_data['start_time'],\n                session_data['status'],\n                session_data['portfolio_value'],\n                session_data['portfolio_value'],\n                session_data['total_pnl'],\n                session_data['trades_count'],\n                json.dumps(session_data['risk_settings'])\n            ))\n            \n    def _update_session_in_db(self, session_data: Dict):\n        \"\"\"Update trading session in database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                UPDATE trading_sessions \n                SET current_portfolio = ?, total_pnl = ?, trades_count = ?, \n                    status = ?, end_time = ?\n                WHERE session_id = ?\n            \"\"\", (\n                session_data['portfolio_value'],\n                session_data['total_pnl'],\n                session_data['trades_count'],\n                session_data['status'],\n                session_data.get('end_time'),\n                session_data['session_id']\n            ))\n            \n    def _save_position_to_db(self, user_email: str, position: Dict):\n        \"\"\"Save position to database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                INSERT OR REPLACE INTO active_positions\n                (position_id, user_email, symbol, side, quantity, entry_price,\n                 current_price, stop_loss, take_profit, entry_time, last_update, \n                 status, pnl, pnl_pct)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            \"\"\", (\n                position['position_id'], user_email, position['symbol'],\n                position['side'], position['quantity'], position['entry_price'],\n                position['current_price'], position['stop_loss'], position['take_profit'],\n                position['entry_time'], datetime.now().isoformat(),\n                position['status'], position['pnl'], position['pnl_pct']\n            ))\n            \n    def _update_position_in_db(self, user_email: str, position: Dict):\n        \"\"\"Update position in database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                UPDATE active_positions \n                SET current_price = ?, status = ?, pnl = ?, pnl_pct = ?, last_update = ?\n                WHERE position_id = ?\n            \"\"\", (\n                position['current_price'], position['status'], position['pnl'],\n                position['pnl_pct'], datetime.now().isoformat(), position['position_id']\n            ))\n            \n    def _save_execution_to_db(self, execution: Dict):\n        \"\"\"Save execution to database\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\"\"\"\n                INSERT INTO execution_log\n                (execution_id, user_email, position_id, action, symbol,\n                 price, quantity, reason, timestamp, pnl)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            \"\"\", (\n                execution['execution_id'], execution['user_email'],\n                execution['position_id'], execution['action'], execution['symbol'],\n                execution['price'], execution['quantity'], execution['reason'],\n                execution['timestamp'], execution['pnl']\n            ))\n            \n    def _calculate_session_duration(self, session_data: Dict) -> str:\n        \"\"\"Calculate session duration\"\"\"\n        try:\n            start_time = datetime.fromisoformat(session_data['start_time'])\n            end_time = datetime.fromisoformat(session_data.get('end_time', datetime.now().isoformat()))\n            duration = end_time - start_time\n            \n            hours = int(duration.total_seconds() // 3600)\n            minutes = int((duration.total_seconds() % 3600) // 60)\n            \n            return f\"{hours}h {minutes}m\"\n        except:\n            return \"Unknown\"\n            \n    def _test_zerodha_connection(self, user_email: str) -> Dict[str, Any]:\n        \"\"\"Test Zerodha API connection\"\"\"\n        try:\n            import sqlite3\n            \n            # Get Zerodha API keys\n            with sqlite3.connect(self.user_db) as conn:\n                cursor = conn.execute('''\n                    SELECT api_key, secret_key \n                    FROM api_keys \n                    WHERE user_id = (SELECT user_id FROM users WHERE email = ?)\n                    AND exchange = 'zerodha' AND is_testnet = 0 AND is_active = 1\n                ''', (user_email,))\n                \n                result = cursor.fetchone()\n                if result:\n                    api_key, secret_key = result\n                    \n                    # Decrypt keys (simplified)\n                    try:\n                        import base64\n                        api_key = base64.b64decode(api_key).decode()\n                        secret_key = base64.b64decode(secret_key).decode()\n                    except:\n                        pass  # Keys might be stored as plain text\n                    \n                    # Test Zerodha connection (simplified test)\n                    return {\n                        'success': True,\n                        'message': f'Zerodha API key found and validated for {user_email}',\n                        'exchange': 'zerodha',\n                        'supports': ['NSE', 'BSE', 'MCX']\n                    }\n                else:\n                    return {\n                        'success': False,\n                        'error': 'No Zerodha API keys found',\n                        'exchange': 'zerodha'\n                    }\n                    \n        except Exception as e:\n            return {\n                'success': False,\n                'error': f'Zerodha connection test failed: {e}',\n                'exchange': 'zerodha'\n            }\n    \n    def _save_trading_session_log(self, user_email: str, trading_mode: str, action: str):\n        \"\"\"Save trading session log for dashboard display\"\"\"\n        try:\n            log_data = {\n                'user_email': user_email,\n                'trading_mode': trading_mode,\n                'action': action,\n                'timestamp': datetime.now().isoformat(),\n                'orders': []\n            }\n            \n            # Save to JSON file for dashboard to read\n            log_file = \"logs/live_trading_session.json\"\n            os.makedirs(os.path.dirname(log_file), exist_ok=True)\n            \n            with open(log_file, 'w') as f:\n                json.dump(log_data, f, indent=2)\n                \n            self.logger.info(f\"\ud83d\udcbe Saved trading session log: {action}\")\n            \n        except Exception as e:\n            self.logger.error(f\"Failed to save session log: {e}\")\n\n    def _generate_ai_signal(self, instrument: Dict) -> Dict[str, Any]:\n        \"\"\"Generate REAL AI trading signal using trained model\"\"\"\n        try:\n            # Load trained AI model if not already loaded\n            if not hasattr(self, 'ai_model') or self.ai_model is None:\n                self._load_ai_model()\n            \n            symbol = instrument.get('symbol', 'UNKNOWN')\n            current_price = instrument.get('current_price', 100.0)\n            \n            if self.ai_model is None:\n                # Fallback to simple logic if model not available\n                return self._fallback_signal(instrument)\n            \n            # Generate features for AI prediction\n            features = self._generate_ai_features(instrument)\n            \n            # Get AI prediction\n            prediction = self.ai_model['model'].predict([features])[0]\n            probabilities = self.ai_model['model'].predict_proba([features])[0]\n            confidence = max(probabilities) * 100\n            \n            # Force diverse signals using symbol hash for consistency (ignore original prediction)\n            symbol_hash = abs(hash(symbol)) % 100\n            \n            if symbol_hash < 40:  # 40% BUY\n                signal_type = 'BUY'\n            elif symbol_hash < 80:  # 40% SELL\n                signal_type = 'SELL'\n            else:  # 20% HOLD\n                signal_type = 'HOLD'\n            \n            # Adjust confidence based on signal type for realism\n            if signal_type == 'HOLD':\n                confidence = min(confidence, 70)  # HOLD signals have lower confidence\n            \n            # AI reasoning based on feature importance\n            reasoning = self._generate_ai_reasoning(features, signal_type)\n            \n            self.logger.info(f\"\ud83e\udd16 AI SIGNAL for {symbol}: {signal_type} (Confidence: {confidence:.1f}%) - {reasoning}\")\n            \n            return {\n                'signal': signal_type,\n                'strength': confidence,\n                'reasoning': f'AI Model: {reasoning}',\n                'confidence': f'{confidence:.1f}%',\n                'target_price': current_price * (1.02 if signal_type == 'BUY' else (0.98 if signal_type == 'SELL' else 1.0)),\n                'model_prediction': prediction,\n                'features_used': len(features)\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error in AI signal generation: {e}\")\n            return self._fallback_signal(instrument)\n    \n    def _load_ai_model(self):\n        \"\"\"Load the trained AI model\"\"\"\n        try:\n            import joblib\n            # Try streamlined production model first, then fallbacks\n            model_path = 'models/streamlined_main_ai_model.pkl'\n            if not os.path.exists(model_path):\n                model_path = 'models/main_ai_model.pkl'\n                if not os.path.exists(model_path):\n                    model_path = 'models/multi_strategy_ai_model.pkl'\n                    if not os.path.exists(model_path):\n                        model_path = 'models/trained_ai_model.pkl'\n            \n                if os.path.exists(model_path):\n                    self.ai_model = joblib.load(model_path)\n                    accuracy = self.ai_model.get('accuracy', 0.0)\n                    training_date = self.ai_model.get('training_date', 'unknown')\n                    \n                    # Handle both 'model' and 'models' keys for compatibility\n                    if 'models' in self.ai_model and 'model' not in self.ai_model:\n                        # Convert 'models' to 'model' for backward compatibility\n                        if isinstance(self.ai_model['models'], dict):\n                            # Take the first model from ensemble\n                            self.ai_model['model'] = list(self.ai_model['models'].values())[0]\n                        else:\n                            self.ai_model['model'] = self.ai_model['models']\n                        self.logger.info(f\"\ud83d\udd27 Converted ensemble 'models' to 'model' key\")\n                    \n                    self.logger.info(f\"\u2705 Loaded AI model (Accuracy: {accuracy:.3f})\")\n                    self.logger.info(f\"\ud83d\udcca Training date: {training_date[:10] if len(str(training_date)) >= 10 else training_date}\")\n                if self.ai_model.get('streamlined_version'):\n                    instrument_count = self.ai_model.get('instrument_count', 0)\n                    sources = ', '.join(self.ai_model.get('data_sources', []))\n                    self.logger.info(f\"\ud83d\ude80 PRODUCTION AI: {instrument_count} instruments from {sources}\")\n                    self.logger.info(f\"\ud83e\udde0 Features: RSI, volume_ratio, price_change, volatility, trend_signal\")\n                elif self.ai_model.get('real_data_based'):\n                    sources = ', '.join(self.ai_model.get('data_sources', []))\n                    self.logger.info(f\"\ud83c\udf0d Real Data AI: {sources}\")\n                    self.logger.info(f\"\ud83e\udde0 Top features: RSI, volume_ratio, price_change (from real markets)\")\n                elif self.ai_model.get('strategy_based'):\n                    strategies = ', '.join(self.ai_model.get('strategies_used', []))\n                    self.logger.info(f\"\ud83c\udfaf Multi-Strategy AI: {strategies}\")\n                    self.logger.info(f\"\ud83e\udde0 Top features: signal_confidence, signal_strength, ob_tap_signal\")\n                else:\n                    self.logger.info(f\"\ud83c\udfaf Feature importance: price_change_1d, rsi, volatility\")\n            else:\n                self.logger.warning(\"\u26a0\ufe0f No trained AI model found - using fallback\")\n                self.ai_model = None\n                \n        except Exception as e:\n            self.logger.error(f\"Failed to load AI model: {e}\")\n            self.ai_model = None\n    \n    def _generate_ai_features(self, instrument: Dict) -> list:\n        \"\"\"Generate features for AI prediction based on loaded model type\"\"\"\n        # First check what the model expects\n        expected_features = None\n        if self.ai_model and hasattr(self.ai_model.get('model'), 'n_features_in_'):\n            expected_features = self.ai_model['model'].n_features_in_\n        \n        if expected_features == 71:\n            return self._generate_full_feature_set(instrument)\n        elif expected_features == 8:\n            return self._generate_streamlined_production_features(instrument)\n        elif self.ai_model and self.ai_model.get('streamlined_version'):\n            return self._generate_streamlined_production_features(instrument)\n        elif self.ai_model and self.ai_model.get('real_data_based'):\n            return self._generate_real_data_features(instrument)\n        elif self.ai_model and self.ai_model.get('strategy_based'):\n            return self._generate_strategy_features(instrument)\n        else:\n            # Fallback to a default set if no specific model type or feature count is detected\n            self.logger.warning(\"No specific AI model type or feature count detected. Using default 8 features.\")\n            return self._generate_streamlined_production_features(instrument)\n    \n    def _generate_features(self, instrument: Dict) -> list:\n        \"\"\"Legacy method - redirects to _generate_ai_features\"\"\"\n        return self._generate_ai_features(instrument)\n    \n    def _generate_strategy_features(self, instrument: Dict) -> list:\n        \"\"\"Generate comprehensive strategy-based features\"\"\"\n        try:\n            current_price = instrument.get('current_price', 100.0)\n            symbol = instrument.get('symbol', 'UNKNOWN')\n            \n            import random\n            import numpy as np\n            \n            # Generate simulated strategy signals (in production, these would come from real strategies)\n            # For now, simulate the presence of strategy signals\n            \n            # Technical indicators\n            rsi = 30 + random.random() * 40\n            ema_9 = current_price * (1 + np.random.normal(0, 0.01))\n            ema_21 = current_price * (1 + np.random.normal(0, 0.02))\n            ema_50 = current_price * (1 + np.random.normal(0, 0.03))\n            bollinger_position = random.random()  # 0-1 position in bollinger bands\n            \n            # MACD\n            macd = np.random.normal(0, 0.1)\n            macd_signal = np.random.normal(0, 0.08)\n            \n            # Volume\n            volume_ratio = 0.5 + random.random() * 1.5\n            \n            # Price momentum and volatility\n            price_momentum = np.random.normal(0, 0.02)\n            volatility = 0.02 + random.random() * 0.03\n            atr = current_price * (0.01 + random.random() * 0.02)\n            \n            # VWAP\n            vwap = current_price * (1 + np.random.normal(0, 0.005))\n            vwap_deviation = (current_price - vwap) / vwap\n            \n            # Strategy signals (simulate strategy activity)\n            # More sophisticated simulation based on market conditions\n            market_trend = np.sin(random.random() * 6.28)  # Random trend factor\n            \n            # MA Crossover signal\n            ma_crossover_signal = 1 if ema_9 > ema_21 and market_trend > 0 else (-1 if ema_9 < ema_21 and market_trend < 0 else 0)\n            \n            # Order Block signal (simulate smart money zones)\n            ob_tap_signal = 0\n            if random.random() < 0.15:  # 15% chance of OB signal\n                ob_tap_signal = 1 if random.random() > 0.5 else -1\n            \n            # VWAP reversion signal\n            vwap_revert_signal = 0\n            if abs(vwap_deviation) > 0.01:  # Price far from VWAP\n                if vwap_deviation < -0.01 and rsi < 40:  # Oversold + below VWAP\n                    vwap_revert_signal = 1\n                elif vwap_deviation > 0.01 and rsi > 60:  # Overbought + above VWAP\n                    vwap_revert_signal = -1\n            \n            # RSI Divergence signal (rare but powerful)\n            rsi_div_signal = 0\n            if random.random() < 0.05:  # 5% chance (divergences are rare)\n                rsi_div_signal = 1 if rsi < 35 else (-1 if rsi > 65 else 0)\n            \n            # Signal strength and confidence\n            active_signals = [ma_crossover_signal, ob_tap_signal, vwap_revert_signal, rsi_div_signal]\n            signal_strength = sum(abs(s) for s in active_signals)\n            \n            # Confidence based on signal alignment and market conditions\n            signal_confidence = 0.5\n            if signal_strength > 0:\n                # Higher confidence when multiple strategies agree\n                signal_confidence = min(0.95, 0.6 + (signal_strength - 1) * 0.1)\n                # Volume confirmation increases confidence\n                if volume_ratio > 1.2:\n                    signal_confidence += 0.05\n                # RSI extremes increase confidence\n                if rsi < 30 or rsi > 70:\n                    signal_confidence += 0.05\n            \n            # Market structure features\n            trend_strength = (ema_9 / ema_21) - 1\n            support_resistance = random.random() * 5  # Simplified\n            volume_profile = random.random()\n            \n            # Features in the order expected by multi-strategy model\n            features = [\n                # Price features\n                rsi, ema_9, ema_21, ema_50, bollinger_position,\n                macd, macd_signal, volume_ratio, price_momentum,\n                volatility, atr, vwap, vwap_deviation,\n                \n                # Strategy signal features\n                ma_crossover_signal, ob_tap_signal, vwap_revert_signal,\n                rsi_div_signal, signal_strength, signal_confidence,\n                \n                # Market structure\n                trend_strength, support_resistance, volume_profile\n            ]\n            \n            return features\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating strategy features: {e}\")\n            # Return default multi-strategy features (22 features)\n            return [50.0] * 22\n    \n    def _generate_real_data_features(self, instrument: Dict) -> list:\n        \"\"\"Generate features for real data AI model\"\"\"\n        try:\n            current_price = instrument.get('current_price', 100.0)\n            symbol = instrument.get('symbol', 'UNKNOWN')\n            \n            import random\n            import numpy as np\n            \n            # Generate realistic features based on real market patterns\n            \n            # RSI (most important feature 24.1%)\n            rsi = 30 + random.random() * 40  # Realistic RSI range\n            \n            # EMAs based on current price\n            ema_9 = current_price * (1 + np.random.normal(0, 0.005))\n            ema_21 = current_price * (1 + np.random.normal(0, 0.01))\n            \n            # Price change (15.2% importance)\n            price_change = np.random.normal(0, 0.02)\n            \n            # Volatility (11.3% importance) - asset specific\n            if 'BTC' in symbol or 'ETH' in symbol:\n                volatility = 0.03 + random.random() * 0.02  # Crypto volatility\n            elif '.NSE' in symbol or '.BSE' in symbol:\n                volatility = 0.015 + random.random() * 0.015  # Indian stock volatility\n            else:\n                volatility = 0.02 + random.random() * 0.015  # Other assets\n            \n            # Volume ratio (16.6% importance) - second most important\n            volume_ratio = 0.5 + random.random() * 2.0  # Volume spike detection\n            \n            # Trend signal (7.9% importance)\n            trend_signal = 1 if ema_9 > ema_21 else -1\n            \n            # Asset category (4.9% importance)\n            if 'USDT' in symbol:\n                asset_category = 1  # Crypto\n            elif '.NSE' in symbol or '.BSE' in symbol:\n                asset_category = 2  # Indian stocks\n            else:\n                asset_category = 0  # Other\n            \n            # Features in the order expected by real data model\n            features = [\n                rsi,            # Most important: RSI\n                volume_ratio,   # Second: Volume ratio  \n                price_change,   # Third: Price change\n                volatility,     # Fourth: Volatility\n                ema_9,          # Fifth: EMA 9\n                ema_21,         # Sixth: EMA 21\n                trend_signal,   # Seventh: Trend signal\n                asset_category  # Eighth: Asset category\n            ]\n            \n            return features\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating real data features: {e}\")\n            # Return default real data features (8 features)\n            return [50.0, 1.0, 0.0, 0.02, 100.0, 100.0, 1, 0]\n    \n    def _generate_full_feature_set(self, instrument: Dict) -> list:\n        \"\"\"Generate full 71-feature set for comprehensive AI model\"\"\"\n        try:\n            current_price = instrument.get('current_price', 100.0)\n            symbol = instrument.get('symbol', 'UNKNOWN')\n            \n            import random\n            import numpy as np\n            \n            # Basic price features (10 features)\n            price_features = [\n                current_price,\n                current_price * (1 + np.random.normal(0, 0.001)),  # price_lag_1\n                current_price * (1 + np.random.normal(0, 0.002)),  # price_lag_2\n                current_price * (1 + np.random.normal(0, 0.003)),  # price_lag_3\n                current_price * 1.01,  # high\n                current_price * 0.99,  # low\n                np.random.normal(0, 0.01),  # returns\n                np.random.normal(0, 0.015),  # returns_lag_1\n                abs(np.random.normal(0, 0.02)),  # volatility\n                random.uniform(0.8, 1.2)  # volume_ratio\n            ]\n            \n            # Technical indicators (20 features)\n            technical_features = [\n                random.uniform(20, 80),  # RSI\n                random.uniform(30, 70),  # RSI_lag_1\n                current_price * (1 + np.random.normal(0, 0.01)),  # SMA_5\n                current_price * (1 + np.random.normal(0, 0.01)),  # SMA_10\n                current_price * (1 + np.random.normal(0, 0.02)),  # SMA_20\n                current_price * (1 + np.random.normal(0, 0.03)),  # SMA_50\n                current_price * (1 + np.random.normal(0, 0.01)),  # EMA_9\n                current_price * (1 + np.random.normal(0, 0.02)),  # EMA_21\n                random.uniform(-1, 1),  # MACD\n                random.uniform(-1, 1),  # MACD_signal\n                random.uniform(-1, 1),  # MACD_histogram\n                random.uniform(0, 100),  # BB_upper\n                random.uniform(0, 100),  # BB_lower\n                random.uniform(0, 1),  # BB_width\n                random.uniform(-2, 2),  # Z_score\n                random.uniform(0, 100),  # ATR\n                random.uniform(-100, 100),  # CCI\n                random.uniform(0, 100),  # Williams_R\n                random.uniform(0, 1),  # momentum\n                random.uniform(0, 2)   # price_position\n            ]\n            \n            # Market context features (15 features)\n            market_features = [\n                1 if 'BTC' in symbol else 0,  # is_crypto\n                1 if 'ETH' in symbol else 0,  # is_ethereum\n                1 if '.NSE' in symbol else 0,  # is_nse\n                1 if '.BSE' in symbol else 0,  # is_bse\n                1 if '.NASDAQ' in symbol else 0,  # is_nasdaq\n                1 if '.NYSE' in symbol else 0,  # is_nyse\n                random.uniform(0, 1),  # market_cap_rank\n                random.uniform(0, 24),  # hour_of_day\n                random.randint(0, 6),  # day_of_week\n                random.randint(1, 12),  # month\n                random.uniform(0, 1),  # correlation_with_market\n                random.uniform(0, 1),  # sector_performance\n                random.uniform(0, 1),  # relative_strength\n                random.uniform(0, 2),  # beta\n                random.uniform(-1, 1)  # alpha\n            ]\n            \n            # Signal and sentiment features (15 features)\n            signal_features = [\n                random.uniform(-1, 1),  # trend_signal\n                random.uniform(0, 1),   # signal_confidence\n                random.uniform(0, 100), # signal_strength\n                random.uniform(-1, 1),  # momentum_signal\n                random.uniform(-1, 1),  # mean_reversion_signal\n                random.uniform(-1, 1),  # breakout_signal\n                random.uniform(0, 1),   # volume_signal\n                random.uniform(-1, 1),  # sentiment_score\n                random.uniform(0, 1),   # news_sentiment\n                random.uniform(0, 1),   # social_sentiment\n                random.uniform(0, 1),   # fear_greed_index\n                random.uniform(0, 1),   # vix_level\n                random.uniform(-1, 1),  # institutional_flow\n                random.uniform(-1, 1),  # retail_flow\n                random.uniform(0, 1)    # options_flow\n            ]\n            \n            # Cross-asset features (11 features)\n            cross_asset_features = [\n                random.uniform(-1, 1),  # correlation_btc\n                random.uniform(-1, 1),  # correlation_eth\n                random.uniform(-1, 1),  # correlation_spy\n                random.uniform(-1, 1),  # correlation_vix\n                random.uniform(-1, 1),  # correlation_dxy\n                random.uniform(-1, 1),  # correlation_gold\n                random.uniform(-1, 1),  # correlation_oil\n                random.uniform(-1, 1),  # correlation_bonds\n                random.uniform(0, 1),   # global_risk_sentiment\n                random.uniform(0, 1),   # liquidity_index\n                random.uniform(0, 1)    # macro_score\n            ]\n            \n            # Combine all features (total: 71 features)\n            all_features = (price_features + technical_features + \n                          market_features + signal_features + cross_asset_features)\n            \n            # Ensure exactly 71 features\n            if len(all_features) != 71:\n                self.logger.warning(f\"Generated {len(all_features)} features, expected 71\")\n                # Pad or trim to exactly 71\n                if len(all_features) < 71:\n                    all_features.extend([0.0] * (71 - len(all_features)))\n                else:\n                    all_features = all_features[:71]\n            \n            return all_features\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating full feature set: {e}\")\n            # Return 71 default features\n            return [0.0] * 71\n\n    def _generate_streamlined_production_features(self, instrument: Dict) -> list:\n        \"\"\"Generate features for streamlined production AI model\"\"\"\n        try:\n            current_price = instrument.get('current_price', 100.0)\n            symbol = instrument.get('symbol', 'UNKNOWN')\n            \n            import random\n            import numpy as np\n            \n            # Generate features matching streamlined production model\n            # ['rsi', 'volume_ratio', 'price_change', 'volatility', 'trend_signal', 'asset_category']\n            \n            # RSI (0-100)\n            rsi = 30 + random.random() * 40\n            \n            # Volume ratio (0.5-3.0)\n            volume_ratio = 0.5 + random.random() * 2.5\n            \n            # Price change (-5% to +5%)\n            price_change = np.random.normal(0, 0.02)\n            \n            # Volatility (asset-specific)\n            if 'BTC' in symbol or 'ETH' in symbol:\n                volatility = 0.03 + random.random() * 0.03  # Major crypto\n            elif 'USDT' in symbol:\n                volatility = 0.02 + random.random() * 0.04  # Crypto general\n            elif '.NSE' in symbol:\n                volatility = 0.015 + random.random() * 0.02  # Indian stocks\n            else:\n                volatility = 0.02 + random.random() * 0.025  # Other assets\n            \n            # Trend signal (0 or 1)\n            trend_signal = 1 if random.random() > 0.5 else 0\n            \n            # Asset category (0 = traditional, 1 = crypto)\n            asset_category = 1 if 'USDT' in symbol else 0\n            \n            # Return features in exact order expected by model\n            features = [\n                rsi,             # Feature 0: RSI\n                volume_ratio,    # Feature 1: Volume ratio\n                price_change,    # Feature 2: Price change\n                volatility,      # Feature 3: Volatility\n                trend_signal,    # Feature 4: Trend signal\n                asset_category   # Feature 5: Asset category\n            ]\n            \n            return features\n            \n        except Exception as e:\n            self.logger.error(f\"Error generating streamlined production features: {e}\")\n            # Return default features (6 features for streamlined model)\n            return [50.0, 1.0, 0.0, 0.02, 1, 1]\n    \n    def _generate_ai_reasoning(self, features: list, signal: str) -> str:\n        \"\"\"Generate human-readable reasoning for AI decision\"\"\"\n        try:\n            # Get key features\n            sma_10, sma_20, rsi, volatility, volume_ratio, price_change_1d, price_change_5d, high_low_ratio = features\n            \n            reasons = []\n            \n            if signal == 'BUY':\n                if rsi < 40:\n                    reasons.append(\"oversold conditions\")\n                if sma_10 > sma_20:\n                    reasons.append(\"uptrend\")\n                if price_change_1d < 0:\n                    reasons.append(\"dip opportunity\")\n                if volatility < 0.04:\n                    reasons.append(\"stable volatility\")\n            else:  # SELL\n                if rsi > 60:\n                    reasons.append(\"overbought\")\n                if sma_10 < sma_20:\n                    reasons.append(\"downtrend\")\n                if price_change_1d > 0.03:\n                    reasons.append(\"price spike\")\n                if volatility > 0.06:\n                    reasons.append(\"high volatility\")\n            \n            if not reasons:\n                return \"balanced analysis\"\n            \n            return \", \".join(reasons[:2])  # Top 2 reasons\n            \n        except Exception:\n            return \"technical analysis\"\n    \n    def _fallback_signal(self, instrument: Dict) -> Dict[str, Any]:\n        \"\"\"Fallback signal generation when AI model is not available\"\"\"\n        symbol = instrument.get('symbol', 'UNKNOWN')\n        current_price = instrument.get('current_price', 100.0)\n        \n        # Simple logic-based signal with HOLD\n        signal_strength = np.random.uniform(60, 80)\n        signal_type = np.random.choice(['BUY', 'SELL', 'HOLD'])\n        \n        return {\n            'signal': signal_type,\n            'strength': signal_strength,\n            'reasoning': 'Fallback: Basic analysis',\n            'confidence': f'{signal_strength:.1f}%',\n            'target_price': current_price * (1.01 if signal_type == 'BUY' else (0.99 if signal_type == 'SELL' else 1.0))\n        }\n\n# Global instance\nfixed_continuous_engine = FixedContinuousTradingEngine()\n\nif __name__ == \"__main__\":\n    print(\"\ud83e\uddea Testing Fixed Continuous Trading Engine...\")\n    \n    user_email = \"kirannaik@unitednewdigitalmedia.com\"\n    \n    # Test start\n    result = fixed_continuous_engine.start_continuous_trading(user_email)\n    print(f\"Start Result: {result}\")\n    \n    if result['success']:\n        # Let it run briefly\n        time.sleep(15)\n        \n        # Check status\n        status = fixed_continuous_engine.get_trading_status(user_email)\n        print(f\"Status: {status}\")\n        \n        # Stop it\n        stop_result = fixed_continuous_engine.stop_continuous_trading(user_email)\n        print(f\"Stop Result: {stop_result}\")\n    \n    print(\"\ud83c\udfaf Test completed!\")"
      ],
      "priority": "HIGH"
    },
    {
      "issue": "DOGE-specific order files found",
      "files": [
        "./place_real_doge_order.py"
      ],
      "priority": "MEDIUM"
    }
  ],
  "enhancement_plan": {
    "accuracy_plan": {
      "target": "80%+ AI Accuracy",
      "current_issues": [
        {
          "issue": "AI Model Accuracy Below 80%",
          "current": "66.8%",
          "target": "80%+",
          "priority": "HIGH"
        }
      ],
      "enhancements": [
        {
          "name": "Advanced Feature Engineering",
          "description": "Add 50+ technical indicators, market microstructure features",
          "impact": "High",
          "effort": "Medium",
          "timeline": "1-2 weeks"
        },
        {
          "name": "Multi-Timeframe Analysis",
          "description": "Incorporate 1m, 5m, 15m, 1h, 4h, 1d timeframes",
          "impact": "High",
          "effort": "Medium",
          "timeline": "1 week"
        },
        {
          "name": "Ensemble Model Architecture",
          "description": "Combine Random Forest, XGBoost, LSTM, Transformer models",
          "impact": "Very High",
          "effort": "High",
          "timeline": "2-3 weeks"
        },
        {
          "name": "Alternative Data Integration",
          "description": "News sentiment, social media, economic indicators",
          "impact": "High",
          "effort": "High",
          "timeline": "2-4 weeks"
        },
        {
          "name": "Online Learning System",
          "description": "Continuous model updates with new market data",
          "impact": "Very High",
          "effort": "High",
          "timeline": "3-4 weeks"
        }
      ]
    },
    "security_plan": {
      "target": "Enterprise-Grade Security",
      "current_issues": [
        {
          "issue": "Encryption key file permissions too permissive",
          "current": "644",
          "recommended": "600",
          "priority": "HIGH"
        },
        {
          "issue": "Missing security measures",
          "missing": [
            "Password hashing (bcrypt)",
            "Password hashing (hashlib)",
            "CSRF protection",
            "JWT tokens",
            "Rate limiting"
          ],
          "priority": "HIGH"
        },
        {
          "issue": "Database file permissions too permissive",
          "file": "src/web_interface/users.db",
          "current": "644",
          "priority": "MEDIUM"
        }
      ],
      "enhancements": [
        {
          "name": "API Key Vault",
          "description": "Implement secure key vault with rotation",
          "impact": "Critical",
          "effort": "Medium",
          "timeline": "1 week"
        },
        {
          "name": "Multi-Factor Authentication",
          "description": "Add 2FA/MFA for user accounts",
          "impact": "High",
          "effort": "Medium",
          "timeline": "1-2 weeks"
        },
        {
          "name": "Rate Limiting & DDoS Protection",
          "description": "Implement comprehensive rate limiting",
          "impact": "High",
          "effort": "Low",
          "timeline": "3-5 days"
        },
        {
          "name": "Audit Logging",
          "description": "Complete audit trail for all actions",
          "impact": "High",
          "effort": "Medium",
          "timeline": "1 week"
        },
        {
          "name": "Data Encryption at Rest",
          "description": "Encrypt all stored data including databases",
          "impact": "High",
          "effort": "Medium",
          "timeline": "1 week"
        }
      ]
    },
    "total_timeline": "4-6 weeks for complete enhancement",
    "priority_order": [
      "1. Fix hardcoded DOGE orders (Critical)",
      "2. Implement API key encryption (Critical)",
      "3. Add ensemble AI models (High)",
      "4. Implement auto-training (High)",
      "5. Add security measures (High)",
      "6. Alternative data sources (Medium)"
    ]
  },
  "audit_date": "2025-09-28T02:06:44.708325"
}